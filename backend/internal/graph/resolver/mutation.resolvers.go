package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"
	"time"

	"backend/internal/auth"
	"backend/internal/graph/errors"
	"backend/internal/graph/generated"
	"backend/internal/graph/model"
	"backend/internal/graph/validation"
	"github.com/google/uuid"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	// Create login request
	loginReq := auth.LoginRequest{
		Email:    email,
		Password: password,
	}

	// Get client IP (this would come from HTTP context in real implementation)
	clientIP := "127.0.0.1" // TODO: Extract from HTTP context

	// Authenticate user
	authResponse, err := r.AuthManager.AuthService.Login(ctx, loginReq, clientIP)
	if err != nil {
		return nil, fmt.Errorf("login failed: %w", err)
	}

	return &model.AuthPayload{
		Token:     authResponse.Token,
		User:      authResponse.User,
		ExpiresAt: authResponse.ExpiresAt,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, email string, password string, name string) (*model.AuthPayload, error) {
	// Validate input
	validator := validation.NewValidator()
	input := model.CreateUserInput{
		Email:    email,
		Password: password,
		Name:     name,
	}
	
	if err := validator.ValidateCreateUserInput(input); err != nil {
		return nil, err
	}

	// Create registration request
	registerReq := auth.RegisterRequest{
		Email:    email,
		Password: password,
		Name:     name,
	}

	// Get client IP (this would come from HTTP context in real implementation)
	clientIP := "127.0.0.1" // TODO: Extract from HTTP context

	// Register user
	authResponse, err := r.AuthManager.AuthService.Register(ctx, registerReq, clientIP)
	if err != nil {
		// Handle specific registration errors
		if err.Error() == "user with email "+email+" already exists" {
			return nil, errors.NewAlreadyExistsError("User with this email")
		}
		return nil, errors.NewInternalError("Registration failed")
	}

	return &model.AuthPayload{
		Token:     authResponse.Token,
		User:      authResponse.User,
		ExpiresAt: authResponse.ExpiresAt,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	// Get current user (must be authenticated)
	user, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Get JWT claims to extract current token
	_, ok := auth.GetClaimsFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("no token claims found")
	}

	// Generate new token (we need to reconstruct the token string)
	// In a real implementation, we'd store the current token or extract it from headers
	newToken, expiresAt, err := r.AuthManager.JWTService.GenerateToken(user)
	if err != nil {
		return nil, fmt.Errorf("failed to refresh token: %w", err)
	}

	return &model.AuthPayload{
		Token:     newToken,
		User:      user,
		ExpiresAt: expiresAt,
	}, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	// Require authentication
	user, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, errors.NewUnauthenticatedError("Authentication required to create posts")
	}

	// Validate input
	validator := validation.NewValidator()
	if err := validator.ValidateCreatePostInput(input); err != nil {
		return nil, err
	}

	// Set default published value
	published := false
	if input.Published != nil {
		published = *input.Published
	}

	// Create post
	post := &model.Post{
		ID:        uuid.New(),
		Title:     input.Title,
		Content:   input.Content,
		AuthorID:  user.ID,
		Tags:      input.Tags,
		Published: published,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Save to database
	if err := r.PostRepo.Create(ctx, post); err != nil {
		return nil, errors.WrapDatabaseError(err, "post creation")
	}

	// Publish real-time event for new post
	if r.SubManager != nil {
		r.SubManager.PublishPostAdded(post)
	}

	return post, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, id string, input model.UpdatePostInput) (*model.Post, error) {
	// Require authentication
	user, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, fmt.Errorf("authentication required: %w", err)
	}

	// Parse post ID
	postID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID: %w", err)
	}

	// Get existing post
	post, err := r.PostRepo.GetByID(ctx, postID)
	if err != nil {
		return nil, fmt.Errorf("post not found: %w", err)
	}

	// Check if user owns the post
	if post.AuthorID != user.ID {
		return nil, fmt.Errorf("unauthorized: you can only update your own posts")
	}

	// Update fields
	if input.Title != nil {
		post.Title = *input.Title
	}
	if input.Content != nil {
		post.Content = *input.Content
	}
	if input.Tags != nil {
		post.Tags = input.Tags
	}
	if input.Published != nil {
		post.Published = *input.Published
	}
	post.UpdatedAt = time.Now()

	// Save to database
	if err := r.PostRepo.Update(ctx, post); err != nil {
		return nil, fmt.Errorf("failed to update post: %w", err)
	}

	// Publish real-time event for updated post
	if r.SubManager != nil {
		r.SubManager.PublishPostUpdated(post)
	}

	return post, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string) (bool, error) {
	// Require authentication
	user, err := auth.RequireUser(ctx)
	if err != nil {
		return false, fmt.Errorf("authentication required: %w", err)
	}

	// Parse post ID
	postID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid post ID: %w", err)
	}

	// Get existing post to check ownership
	post, err := r.PostRepo.GetByID(ctx, postID)
	if err != nil {
		return false, fmt.Errorf("post not found: %w", err)
	}

	// Check if user owns the post
	if post.AuthorID != user.ID {
		return false, fmt.Errorf("unauthorized: you can only delete your own posts")
	}

	// Delete from database
	if err := r.PostRepo.Delete(ctx, postID); err != nil {
		return false, fmt.Errorf("failed to delete post: %w", err)
	}

	return true, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, postID string, content string) (*model.Comment, error) {
	// Require authentication
	user, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, errors.NewUnauthenticatedError("Authentication required to add comments")
	}

	// Validate input
	validator := validation.NewValidator()
	if err := validator.ValidateCommentContent(content); err != nil {
		return nil, err
	}

	// Validate and parse post ID
	if postID == "" {
		return nil, errors.NewValidationError("Post ID cannot be empty", "postId")
	}
	
	postUUID, err := uuid.Parse(postID)
	if err != nil {
		return nil, errors.NewInvalidFormatError("Invalid post ID format", "postId")
	}

	// Verify post exists
	_, err = r.PostRepo.GetByID(ctx, postUUID)
	if err != nil {
		return nil, errors.NewNotFoundError("Post")
	}

	// Create comment
	comment := &model.Comment{
		ID:        uuid.New(),
		Content:   content,
		AuthorID:  user.ID,
		PostID:    postUUID,
		CreatedAt: time.Now(),
	}

	// Save to database
	if err := r.CommentRepo.Create(ctx, comment); err != nil {
		return nil, errors.WrapDatabaseError(err, "comment creation")
	}

	// Publish real-time event for new comment
	if r.SubManager != nil {
		r.SubManager.PublishCommentAdded(comment)
	}

	return comment, nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (bool, error) {
	// Require authentication
	user, err := auth.RequireUser(ctx)
	if err != nil {
		return false, fmt.Errorf("authentication required: %w", err)
	}

	// Parse comment ID
	commentID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid comment ID: %w", err)
	}

	// Get existing comment to check ownership
	comment, err := r.CommentRepo.GetByID(ctx, commentID)
	if err != nil {
		return false, fmt.Errorf("comment not found: %w", err)
	}

	// Check if user owns the comment
	if comment.AuthorID != user.ID {
		return false, fmt.Errorf("unauthorized: you can only delete your own comments")
	}

	// Delete from database
	if err := r.CommentRepo.Delete(ctx, commentID); err != nil {
		return false, fmt.Errorf("failed to delete comment: %w", err)
	}

	return true, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }