package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"fmt"

	"backend/internal/auth"
	"backend/internal/graph/errors"
	"backend/internal/graph/generated"
	"backend/internal/graph/model"
	"backend/internal/graph/validation"
	"backend/internal/repository"
	"github.com/google/uuid"
)

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Require authentication
	user, err := auth.RequireUser(ctx)
	if err != nil {
		return nil, errors.NewUnauthenticatedError("Authentication required to access user profile")
	}
	return user, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	// Validate and parse UUID
	if id == "" {
		return nil, errors.NewValidationError("User ID cannot be empty", "id")
	}
	
	userID, err := uuid.Parse(id)
	if err != nil {
		return nil, errors.NewInvalidFormatError("Invalid user ID format", "id")
	}

	// Get user from repository
	user, err := r.UserRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, errors.WrapDatabaseError(err, "user lookup")
	}

	return user, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, filters *model.PostFilters, pagination *model.PaginationInput) (*model.PostConnection, error) {
	// Validate pagination input
	validator := validation.NewValidator()
	if err := validator.ValidatePaginationInput(pagination); err != nil {
		return nil, err
	}
	
	// Set default pagination
	limit := 20
	offset := 0
	
	if pagination != nil {
		if pagination.Limit != nil && *pagination.Limit > 0 {
			limit = *pagination.Limit
		}
		if pagination.Page != nil && *pagination.Page > 1 {
			offset = (*pagination.Page - 1) * limit
		}
	}

	// Convert GraphQL filters to repository filters
	repoFilters := &repository.PostFilters{}
	if filters != nil {
		if filters.AuthorID != nil {
			authorID, err := uuid.Parse(*filters.AuthorID)
			if err != nil {
				return nil, errors.NewInvalidFormatError("Invalid author ID format", "authorId")
			}
			repoFilters.AuthorID = &authorID
		}
		if filters.Published != nil {
			repoFilters.Published = filters.Published
		}
		if len(filters.Tags) > 0 {
			if err := validator.ValidateTags(filters.Tags); err != nil {
				return nil, err
			}
			repoFilters.Tags = filters.Tags
		}
		if filters.SearchTerm != nil {
			if err := validator.ValidateSearchQuery(*filters.SearchTerm); err != nil {
				return nil, err
			}
			repoFilters.SearchTerm = filters.SearchTerm
		}
	}

	// Get posts from repository
	posts, err := r.PostRepo.List(ctx, repoFilters, limit, offset)
	if err != nil {
		return nil, errors.WrapDatabaseError(err, "post listing")
	}

	// Get total count
	totalCount, err := r.PostRepo.Count(ctx, repoFilters)
	if err != nil {
		return nil, errors.WrapDatabaseError(err, "post counting")
	}

	// Create edges
	edges := make([]*model.PostEdge, len(posts))
	for i, post := range posts {
		edges[i] = &model.PostEdge{
			Node:   post,
			Cursor: fmt.Sprintf("cursor_%s", post.ID.String()),
		}
	}

	// Calculate pagination info
	hasNextPage := offset+len(posts) < totalCount
	hasPreviousPage := offset > 0
	
	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.PostConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: hasPreviousPage,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: totalCount,
	}, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	// Parse UUID
	postID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid post ID: %w", err)
	}

	// Get post from repository
	post, err := r.PostRepo.GetByID(ctx, postID)
	if err != nil {
		return nil, fmt.Errorf("post not found: %w", err)
	}

	return post, nil
}

// SearchPosts is the resolver for the searchPosts field.
func (r *queryResolver) SearchPosts(ctx context.Context, query string, limit *int) ([]*model.Post, error) {
	// Validate search query
	validator := validation.NewValidator()
	if err := validator.ValidateSearchQuery(query); err != nil {
		return nil, err
	}
	
	// Validate and set limit
	searchLimit := 10
	if limit != nil {
		if *limit < 1 {
			return nil, errors.NewValidationError("Search limit must be at least 1", "limit")
		}
		if *limit > 50 {
			return nil, errors.NewValidationError("Search limit cannot exceed 50", "limit")
		}
		searchLimit = *limit
	}

	// Search posts
	posts, err := r.PostRepo.Search(ctx, query, searchLimit)
	if err != nil {
		return nil, errors.WrapDatabaseError(err, "post search")
	}

	return posts, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }